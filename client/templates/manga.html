<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Manga</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="/static/styles/style.css">
</head>

<body class="manga-page">
	<header class="site default-header">
		<div class="wrap">
			<div class="brand">
				<span class="logo"></span>
				<a href="/">MangaReader<span class="accent">+</span></a>
			</div>
		</div>
	</header>

	<div class="container">
		<div class="summary-background">
			<div class="summary-panel">
			<div class="breadcrumbs"><a href="/">Home</a> &raquo; <span id="manga-breadcrumb-title"></span></div>
			<div class="manga-info">
				<div class="cover">
					<img id="coverImg" src="" alt="Cover image">
				</div>
				<div class="info">
					<h1 id="title">Loading...</h1>
					<div class="meta-list">
						<div class="meta-item"><strong>Author:</strong> <span id="author"></span></div>
						<div class="meta-item"><strong>Status:</strong> <span id="status"></span></div>
						<div class="meta-item"><strong>Rank:</strong> <span id="rank"></span></div>
						<div class="meta-item"><strong>Bookmarked:</strong> <span id="bookmarked"></span></div>
						<div class="meta-item hidden" id="source-item"><strong>Source:</strong> <a id="sourceLink" target="_blank" rel="noopener noreferrer">Visit Source</a></div>
					</div>
					<div id="genres" class="genres"></div>
					{% if current_user.is_authenticated %}
						<div class="manga-actions">
							<button id="bookmarkBtn" class="btn secondary">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="none">
									<path d="M19 21L12 16L5 21V5C5 4.46957 5.21071 3.96086 5.58579 3.58579C5.96086 3.21071 6.46957 3 7 3H17C17.5304 3 18.0391 3.21071 18.4142 3.58579C18.7893 3.96086 19 4.46957 19 5V21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
								</svg>
								<span id="bookmarkText">Add to Bookmarks</span>
							</button>
						</div>
					{% endif %}
				</div>
			</div>
			<div id="summary">
				<p id="desc"></p>
			</div>
			<a id="read-more">Read more</a>
		</div>
	</div>
	<div class="chapters-panel">
		<div class="chapters-header">
			<h2>Chapters</h2>
			<div class="chapter-controls">
				<input type="text" id="chapterSearch" placeholder="Filter chapters...">
				<button id="sortChaptersBtn">Sort: Newest</button>
			</div>
		</div>
		<div id="chapters" class="chapters-list"></div>
	</div>

	<script>
		const pathParts = window.location.pathname.split("/");
		const slug = pathParts[2]; // /manga/<slug>
		if (!slug) {
			document.querySelector('.container').innerHTML =
				'<p class="muted">Invalid manga URL.</p>';
		}

		const chaptersContainer = document.getElementById('chapters');
		const chapterSearch = document.getElementById('chapterSearch');
		const sortBtn = document.getElementById('sortChaptersBtn');
		const summaryDiv = document.getElementById('summary');
		const readMoreBtn = document.getElementById('read-more');

		let currentChapters = [];
		let sortAsc = false;

		function renderChapters(chapters) {
			const query = chapterSearch.value.toLowerCase();
			let filtered = chapters.filter(c => c.number.toString().includes(query) || (c.title || '').toLowerCase().includes(query));

			if (sortAsc) {
				filtered.sort((a, b) => a.number - b.number);
			} else {
				filtered.sort((a, b) => b.number - a.number);
			}

			chaptersContainer.innerHTML = filtered.map(c => `
					<a href="/manga/${slug}/chapter-${c.number}" class="chapter-item" data-chapter="${c.number}">
						<span class="chapter-title">Ch. ${c.number}${c.title ? ` | ${c.title}` : ''}</span>
						<span class="release-date">${c.release_date || ''}</span>
					</a>
			`).join('');
		}

		// Set up single delegated click handler (outside renderChapters to prevent memory leaks)
		let chapterClickHandlerAttached = false;
		function setupChapterClickHandler() {
			if (chapterClickHandlerAttached) return;
			chapterClickHandlerAttached = true;
			
			// Cache scroll positions to avoid repeated API calls
			const scrollCache = new Map();
			
			// Update href on mousedown for middle-click and modifier key support
			chaptersContainer.addEventListener('mousedown', async (ev) => {
				const anchor = ev.target.closest && ev.target.closest('a.chapter-item');
				if (!anchor) return;
				
				const chapterNum = anchor.dataset.chapter;
				if (!chapterNum) return;
				
				// Check cache first, then fetch if needed
				let scroll = scrollCache.get(chapterNum);
				if (scroll === undefined) {
					try {
						const res = await fetch(`/api/history/scroll?manga_slug=${encodeURIComponent(slug)}&chapter=${chapterNum}`);
						if (res.ok) {
							const j = await res.json();
							scroll = parseInt(j && j.scroll || 0, 10) || 0;
						} else {
							scroll = 0;
						}
					} catch (err) {
						scroll = 0;
					}
					scrollCache.set(chapterNum, scroll);
				}
				
				// Update href with scroll parameter if available
				const baseHref = `/manga/${slug}/chapter-${chapterNum}`;
				anchor.href = scroll > 0 ? `${baseHref}?scroll=${scroll}` : baseHref;
			});
			
			// Main click handler for left-click navigation
			chaptersContainer.addEventListener('click', async (ev) => {
				const anchor = ev.target.closest && ev.target.closest('a.chapter-item');
				if (!anchor) return;

				// Let modified clicks and non-left clicks proceed normally (href already updated on mousedown)
				if (ev.button !== 0 || ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey) return;

				// For regular left clicks, we can use the updated href or navigate immediately
				// The href should already be updated from mousedown, so just let it proceed naturally
			});
		}

		sortBtn.addEventListener('click', () => {
			sortAsc = !sortAsc;
			sortBtn.textContent = sortAsc ? 'Sort: Oldest' : 'Sort: Newest';
			renderChapters(currentChapters);
		});

		chapterSearch.addEventListener('input', () => renderChapters(currentChapters));

		readMoreBtn.addEventListener('click', () => {
			summaryDiv.classList.toggle('expanded');
			readMoreBtn.textContent = summaryDiv.classList.contains('expanded') ? 'Read less' : 'Read more';
		});

		fetch(`/api/manga/${slug}`)
			.then(r => r.ok ? r.json() : {})
			.then(data => {
				if (!data || !data.title) {
					document.querySelector('.container').innerHTML =
						'<p class="muted">Failed to load manga details.</p>';
					return;
				}

				document.title = data.title;
				document.getElementById('title').textContent = data.title;
				document.getElementById('manga-breadcrumb-title').textContent = data.title;
				document.getElementById('author').textContent = data.author || '';
				document.getElementById('status').textContent = data.status || 'Unknown';
				document.getElementById('rank').textContent = data.rank || 'N/A';
				document.getElementById('bookmarked').textContent = data.bookmarked || 0;
				
				// Check bookmark status if user is logged in
				{% if current_user.is_authenticated %}
					fetch(`/api/bookmark/check/${slug}`)
						.then(r => r.json())
						.then(bookmarkData => {
							updateBookmarkButton(bookmarkData.bookmarked);
						})
						.catch(() => console.error('Failed to check bookmark status'));
				{% endif %}
				// helper to build a URL-friendly slug for genre links
				function slugify(str) {
					return (str || '')
						.toString()
						.trim()
						.toLowerCase()
						.replace(/[^a-z0-9]+/g, '-')
						.replace(/^-+|-+$/g, '');
				}
				// render genre links that navigate to the pre-filtered genre page
				document.getElementById('genres').innerHTML = (data.genres || []).map(g => {
					const slugged = slugify(g);
					return `<a href="/genre/${slugged}" class="genre-tag">${g}</a>`;
				}).join('');
				document.getElementById('desc').textContent = data.description || '';
				document.getElementById('coverImg').src = data.thumbnail || '';
				document.getElementById('coverImg').alt = data.title;
				document.querySelector('.summary-background').style.cssText = "";

				// After all fonts are loaded, check if the summary text is overflowing.
				// This is the most reliable way to get the correct height.
				document.fonts.ready.then(() => {
					if (summaryDiv.scrollHeight <= summaryDiv.clientHeight) {
						readMoreBtn.style.display = 'none';
					}
				});

				const sourceItem = document.getElementById('source-item');
				if (data.url) {
					document.getElementById('sourceLink').href = data.url;
					sourceItem.style.display = 'block';
				}

				currentChapters = data.chapters || [];
				renderChapters(currentChapters);
				setupChapterClickHandler(); // Set up click handler once after chapters load
			})
			.catch(() => {
				document.querySelector('.container').innerHTML =
					'<p class="muted">Failed to load manga info.</p>';
			});

		{% if current_user.is_authenticated %}
		// Bookmark functionality
		function updateBookmarkButton(isBookmarked) {
			const btn = document.getElementById('bookmarkBtn');
			const text = document.getElementById('bookmarkText');
			const svg = btn.querySelector('svg path');
			
			if (isBookmarked) {
				btn.classList.remove('secondary');
				btn.classList.add('primary');
				text.textContent = 'Remove Bookmark';
				svg.setAttribute('fill', 'currentColor');
			} else {
				btn.classList.remove('primary');
				btn.classList.add('secondary');
				text.textContent = 'Add to Bookmarks';
				svg.setAttribute('fill', 'none');
			}
		}

		document.getElementById('bookmarkBtn')?.addEventListener('click', async () => {
			const btn = document.getElementById('bookmarkBtn');
			const text = document.getElementById('bookmarkText');
			const isBookmarked = btn.classList.contains('primary');
			
			try {
				const response = await fetch(`/api/bookmark/${slug}`, {
					method: isBookmarked ? 'DELETE' : 'POST',
					headers: { 'Content-Type': 'application/json' }
				});
				
				if (response.ok) {
					updateBookmarkButton(!isBookmarked);
				} else {
					alert('Failed to update bookmark');
				}
			} catch (error) {
				alert('Error updating bookmark');
			}
		});
		{% endif %}
	</script>
</body>
</html>
