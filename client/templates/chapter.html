<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Chapter</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="/static/styles/style.css">
</head>

<body>
	<header class="site default-header">
		<div class="wrap">
			<div class="brand">
				<span class="logo"></span>
				<a href="/">MangaReader<span class="accent">+</span></a>
			</div>
		</div>
	</header>

	<div class="container chapter">
		<div class="chapter-header">
			<h1 id="mangaTitle"></h1>
			<div class="breadcrumbs"><a href="/">Home</a> &raquo; <a id="mangaLink" href=""></a> &raquo; <span id="chapterTitle"></span></div>
		</div>
		<div class="nav-controls">
			<a id="prevBtn" class="btn">Prev</a>
			<select id="chapterSelect"></select>
			<a id="nextBtn" class="btn">Next</a>
		</div>
		<div id="pages"></div>
	<div class="nav-controls mt-20">
			<a id="prevBtnBottom" class="btn">Prev</a>
			<select id="chapterSelectBottom"></select>
			<a id="nextBtnBottom" class="btn">Next</a>
		</div>
	</div>

	<script>
		// Parse slug & chapter number from URL path
		const pathParts = window.location.pathname.split("/");
		const slug = pathParts[2];
		let chapterPart = pathParts[3];
		let chapterNumber = 1;
		if (chapterPart && chapterPart.startsWith("chapter-")) {
			chapterNumber = parseInt(chapterPart.replace("chapter-", ""), 10) || 1;
		}

		const chapterSelect = document.getElementById('chapterSelect');
		const chapterSelectBottom = document.getElementById('chapterSelectBottom');
		const prevBtn = document.getElementById('prevBtn');
		const nextBtn = document.getElementById('nextBtn');
		const prevBtnBottom = document.getElementById('prevBtnBottom');
		const nextBtnBottom = document.getElementById('nextBtnBottom');
		const pagesContainer = document.getElementById('pages');
		const mangaTitleEl = document.getElementById('mangaTitle');
		const mangaLinkEl = document.getElementById('mangaLink');
		const chapterTitleEl = document.getElementById('chapterTitle');

		let chapters = [];
		let currentIndex = 0;

		// Fetch manga details for title and breadcrumbs
		fetch(`/api/manga/${slug}`)
			.then(r => r.json())
			.then(data => {
				if (data && data.title) {
					mangaTitleEl.textContent = data.title;
					mangaLinkEl.href = `/manga/${slug}`;
					mangaLinkEl.textContent = data.title;
				}
			});

		// Load chapters and wire navigation + scroll restore/saving
		fetch(`/api/manga/${slug}/all_chapters`)
			.then(r => r.json())
			.then(data => {
				chapters = data.chapters || [];
				if (!chapters || !chapters.length) {
					pagesContainer.innerHTML = '<p class="muted">No chapters found.</p>';
					return;
				}

				const chapterOptions = chapters.map((c, idx) =>
					`<option value="${idx}">Ch. ${c.number}${c.title ? ` | ${c.title}` : ''}</option>`
				).join('');
				chapterSelect.innerHTML = chapterOptions;
				chapterSelectBottom.innerHTML = chapterOptions;

				currentIndex = chapters.findIndex(c => c.number === chapterNumber);
				if (currentIndex === -1) currentIndex = 0;

				// Hide/show nav buttons based on chapter index
				if (currentIndex === 0) {
					prevBtn.style.display = 'none';
					prevBtnBottom.style.display = 'none';
				}
				if (currentIndex === chapters.length - 1) {
					nextBtn.style.display = 'none';
					nextBtnBottom.style.display = 'none';
				}

				chapterSelect.selectedIndex = currentIndex;
				chapterSelectBottom.selectedIndex = currentIndex;

				function navigateToChapter(index) {
					if (index < 0 || index >= chapters.length) return;
					const chapter = chapters[index];
					window.location.href = `/manga/${slug}/chapter-${chapter.number}`;
				}

				function loadChapter(index) {
					const chapter = chapters[index];
					chapterTitleEl.textContent = `Ch. ${chapter.number}${chapter.title ? ` | ${chapter.title}` : ''}`;
					document.title = `${mangaTitleEl.textContent} - Ch. ${chapter.number}${chapter.title ? ` | ${chapter.title}` : ''}`;

					// If a ?scroll=<px> query param was included (from history links), prefer it
					// Read it before we replace the history state (which removes the query param)
					const urlParams = new URLSearchParams(window.location.search);
					const queryScroll = parseInt(urlParams.get('scroll') || '0', 10) || 0;
					history.replaceState(null, '', `/manga/${slug}/chapter-${chapter.number}`);
					pagesContainer.innerHTML = '<p class="muted">Loading pages...</p>';

					// Create placeholder elements first (100px height each)
					const placeholders = chapter.pages.map((_, index) => 
						`<div class="page-placeholder" data-page="${index}" style="height: 100px; background: #333; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; color: #666;">Loading page ${index + 1}...</div>`
					).join('');
					pagesContainer.innerHTML = placeholders;

					// Get saved image position from query or API
					let targetImageIndex = 0;
					if (queryScroll > 0) {
						// If queryScroll is provided, treat it as image index
						targetImageIndex = Math.max(0, Math.min(queryScroll, chapter.pages.length - 1));
					}

					// Scroll to target placeholder immediately
					if (targetImageIndex > 0) {
						const targetPlaceholder = document.querySelector(`[data-page="${targetImageIndex}"]`);
						if (targetPlaceholder) {
							targetPlaceholder.scrollIntoView({ behavior: 'auto', block: 'start' });
						}
					}

					// Preload images and replace placeholders
					let loadedImages = 0;
					const imageElements = chapter.pages.map((pageSrc, index) => {
						const img = new Image();
						img.src = pageSrc;
						img.onload = () => {
							loadedImages++;
							// Replace individual placeholder with actual image
							const placeholder = document.querySelector(`[data-page="${index}"]`);
							if (placeholder) {
								const imgElement = document.createElement('img');
								imgElement.src = pageSrc;
								imgElement.alt = `Page ${index + 1}`;
								imgElement.style.display = 'block';
								imgElement.style.maxWidth = '100%';
								imgElement.style.marginBottom = '5px';
								placeholder.parentNode.replaceChild(imgElement, placeholder);
							}

							// After all images loaded, restore scroll to saved image position
							if (loadedImages === chapter.pages.length && targetImageIndex === 0) {
								// Only fetch saved position if no query scroll was provided
								restoreSavedImagePosition(chapter.number);
							}
						};
						return img;
					});

					chapterSelect.selectedIndex = currentIndex;
					chapterSelectBottom.selectedIndex = currentIndex;

					function restoreSavedImagePosition(chapterNumber) {
						try {
							fetch(`/api/history/scroll?manga_slug=${encodeURIComponent(slug)}&chapter=${chapterNumber}`)
								.then(r => r.json())
								.then(j => {
									const savedImageIndex = parseInt(j && j.image_index || 0, 10) || 0;
									const scrollOffsetPercent = parseInt(j && j.scroll_offset_percent || 0, 10) || 0;
									
									if (savedImageIndex > 0 || scrollOffsetPercent > 0) {
										// Scroll to the saved image and position within that image
										setTimeout(() => {
											const targetImg = pagesContainer.children[savedImageIndex];
											if (targetImg) {
												const rect = targetImg.getBoundingClientRect();
												const imgTop = rect.top + (window.scrollY || window.pageYOffset || 0);
												
												// Calculate the exact scroll position within the image
												const offsetInImage = (rect.height * scrollOffsetPercent) / 100;
												const targetScrollPosition = imgTop + offsetInImage;
												
												window.scrollTo({ 
													top: Math.max(0, targetScrollPosition), 
													behavior: 'auto' 
												});
											}
										}, 300); // Slightly longer delay for image layout
									}
								})
								.catch(() => {});
						} catch (e) { /* ignore */ }
					}

					// Setup scroll-saving for this chapter (debounced)
					setupScrollSaving(chapter.number);
				}

				prevBtn.onclick = () => navigateToChapter(currentIndex - 1);
				nextBtn.onclick = () => navigateToChapter(currentIndex + 1);
				chapterSelect.onchange = () => navigateToChapter(parseInt(chapterSelect.value));

				prevBtnBottom.onclick = () => navigateToChapter(currentIndex - 1);
				nextBtnBottom.onclick = () => navigateToChapter(currentIndex + 1);
				chapterSelectBottom.onchange = () => navigateToChapter(parseInt(chapterSelectBottom.value));

				loadChapter(currentIndex);
			})
			.catch(() => {
				pagesContainer.innerHTML = '<p class="muted">Failed to load chapters.</p>';
			});

		// Image-based scroll saving logic
		let _scrollTimer = null;
		let _currentChapter = null;
		let _lastSavedImageIndex = -1; // Track last saved image index to avoid redundant saves
		let _lastSavedScrollOffset = 0; // Track scroll offset within current image
		
		function setupScrollSaving(chapterNumber) {
			_currentChapter = chapterNumber;
			_lastSavedImageIndex = -1;
			_lastSavedScrollOffset = 0;

			// Remove previously attached handler, then add a fresh one
			window.removeEventListener('scroll', _onScroll);
			window.addEventListener('scroll', _onScroll);

			function _onScroll() {
				if (_scrollTimer) clearTimeout(_scrollTimer);
				_scrollTimer = setTimeout(() => {
					const currentImageIndex = getCurrentVisibleImageIndex();
					const scrollOffsetPercent = getCurrentScrollOffsetInImage();
					
					// Save if image index changed OR if we've scrolled significantly within the same image (>10% change)
					const shouldSave = currentImageIndex !== _lastSavedImageIndex || 
									  (currentImageIndex === _lastSavedImageIndex && Math.abs(scrollOffsetPercent - (_lastSavedScrollOffset || 0)) > 10);
					
					if (shouldSave && currentImageIndex >= 0) {
						sendImagePosition(_currentChapter, currentImageIndex, scrollOffsetPercent);
						_lastSavedImageIndex = currentImageIndex;
						_lastSavedScrollOffset = scrollOffsetPercent;
					}
				}, 500);
			}
		}

		function getCurrentVisibleImageIndex() {
			const images = pagesContainer.children;
			const scrollTop = window.scrollY || window.pageYOffset || 0;
			const viewportTop = scrollTop;
			const viewportBottom = scrollTop + window.innerHeight;

			// Find which image the viewport center is currently in
			for (let i = 0; i < images.length; i++) {
				const img = images[i];
				const rect = img.getBoundingClientRect();
				const imgTop = rect.top + scrollTop;
				const imgBottom = imgTop + rect.height;

				// Check if viewport center is within this image
				const viewportCenter = scrollTop + (window.innerHeight / 2);
				if (viewportCenter >= imgTop && viewportCenter <= imgBottom) {
					return i;
				}
			}

			// Fallback: find the image that has the most visible area
			let maxVisibleArea = 0;
			let bestIndex = 0;

			for (let i = 0; i < images.length; i++) {
				const img = images[i];
				const rect = img.getBoundingClientRect();
				const imgTop = rect.top + scrollTop;
				const imgBottom = imgTop + rect.height;

				// Calculate visible area of this image
				const visibleTop = Math.max(imgTop, viewportTop);
				const visibleBottom = Math.min(imgBottom, viewportBottom);
				const visibleArea = Math.max(0, visibleBottom - visibleTop);

				if (visibleArea > maxVisibleArea) {
					maxVisibleArea = visibleArea;
					bestIndex = i;
				}
			}

			return bestIndex;
		}

		function getCurrentScrollOffsetInImage() {
			const images = pagesContainer.children;
			const scrollTop = window.scrollY || window.pageYOffset || 0;
			const currentImageIndex = getCurrentVisibleImageIndex();
			
			if (currentImageIndex >= 0 && currentImageIndex < images.length) {
				const img = images[currentImageIndex];
				const rect = img.getBoundingClientRect();
				const imgTop = rect.top + scrollTop;
				
				// Calculate how far into this image we are (as a percentage)
				const offsetInImage = scrollTop - imgTop;
				const imageHeight = rect.height;
				const percentInImage = imageHeight > 0 ? Math.max(0, Math.min(100, (offsetInImage / imageHeight) * 100)) : 0;
				
				return Math.round(percentInImage);
			}
			
			return 0;
		}

		function sendImagePosition(chapterNumber, imageIndex, scrollOffsetPercent = 0) {
			try {
				const totalImages = pagesContainer.children.length;
				// Calculate overall progress: (imageIndex + scrollOffsetPercent/100) / totalImages
				const overallProgress = totalImages > 0 ? 
					((imageIndex + (scrollOffsetPercent / 100)) / totalImages) * 100 : 0;
				const percent = Math.round(Math.max(0, Math.min(100, overallProgress)));
				
				// Send image position with error handling
				fetch('/api/history/scroll', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						manga_slug: slug, 
						chapter: chapterNumber, 
						scroll: 0, // Keep for backward compatibility
						image_index: imageIndex,
						scroll_offset_percent: scrollOffsetPercent,
						percent: percent, 
						manga_title: mangaTitleEl.textContent || 'Unknown' 
					})
				}).catch(() => {
					// Silently handle network errors - scroll saving is not critical
					console.debug('Failed to save image position');
				});
			} catch (e) { 
				console.debug('Error in sendImagePosition:', e);
			}
		}
	</script>
</body>

</html>
