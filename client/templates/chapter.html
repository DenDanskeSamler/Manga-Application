<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Chapter</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="/static/styles/style.css">
</head>

<body>
	<header class="site default-header">
		<div class="wrap">
			<div class="brand">
				<span class="logo"></span>
				<a href="/">MangaReader<span class="accent">+</span></a>
			</div>
		</div>
	</header>

	<div class="container chapter">
		<div class="chapter-header">
			<h1 id="mangaTitle"></h1>
			<div class="breadcrumbs"><a href="/">Home</a> &raquo; <a id="mangaLink" href=""></a> &raquo; <span id="chapterTitle"></span></div>
		</div>
		<div class="nav-controls">
			<a id="prevBtn" class="btn">Prev</a>
			<select id="chapterSelect"></select>
			<a id="nextBtn" class="btn">Next</a>
		</div>
		<div id="pages"></div>
	<div class="nav-controls mt-20">
			<a id="prevBtnBottom" class="btn">Prev</a>
			<select id="chapterSelectBottom"></select>
			<a id="nextBtnBottom" class="btn">Next</a>
		</div>
	</div>

	<script>
		// Parse slug & chapter number from URL path
		const pathParts = window.location.pathname.split("/");
		const slug = pathParts[2];
		let chapterPart = pathParts[3];
		let chapterNumber = 1;
		if (chapterPart && chapterPart.startsWith("chapter-")) {
			chapterNumber = parseInt(chapterPart.replace("chapter-", ""), 10) || 1;
		}

		const chapterSelect = document.getElementById('chapterSelect');
		const chapterSelectBottom = document.getElementById('chapterSelectBottom');
		const prevBtn = document.getElementById('prevBtn');
		const nextBtn = document.getElementById('nextBtn');
		const prevBtnBottom = document.getElementById('prevBtnBottom');
		const nextBtnBottom = document.getElementById('nextBtnBottom');
		const pagesContainer = document.getElementById('pages');
		const mangaTitleEl = document.getElementById('mangaTitle');
		const mangaLinkEl = document.getElementById('mangaLink');
		const chapterTitleEl = document.getElementById('chapterTitle');

		let chapters = [];
		let currentIndex = 0;

		// Fetch manga details for title and breadcrumbs
		fetch(`/api/manga/${slug}`)
			.then(r => r.json())
			.then(data => {
				if (data && data.title) {
					mangaTitleEl.textContent = data.title;
					mangaLinkEl.href = `/manga/${slug}`;
					mangaLinkEl.textContent = data.title;
				}
			});

		// Load chapters and wire navigation + scroll restore/saving
		fetch(`/api/manga/${slug}/all_chapters`)
			.then(r => r.json())
			.then(data => {
				chapters = data.chapters || [];
				if (!chapters || !chapters.length) {
					pagesContainer.innerHTML = '<p class="muted">No chapters found.</p>';
					return;
				}

				const chapterOptions = chapters.map((c, idx) =>
					`<option value="${idx}">Ch. ${c.number}${c.title ? ` | ${c.title}` : ''}</option>`
				).join('');
				chapterSelect.innerHTML = chapterOptions;
				chapterSelectBottom.innerHTML = chapterOptions;

				currentIndex = chapters.findIndex(c => c.number === chapterNumber);
				if (currentIndex === -1) currentIndex = 0;

				// Hide/show nav buttons based on chapter index
				if (currentIndex === 0) {
					prevBtn.style.display = 'none';
					prevBtnBottom.style.display = 'none';
				}
				if (currentIndex === chapters.length - 1) {
					nextBtn.style.display = 'none';
					nextBtnBottom.style.display = 'none';
				}

				chapterSelect.selectedIndex = currentIndex;
				chapterSelectBottom.selectedIndex = currentIndex;

				function navigateToChapter(index) {
					if (index < 0 || index >= chapters.length) return;
					const chapter = chapters[index];
					window.location.href = `/manga/${slug}/chapter-${chapter.number}`;
				}

				function loadChapter(index) {
					const chapter = chapters[index];
					chapterTitleEl.textContent = `Ch. ${chapter.number}${chapter.title ? ` | ${chapter.title}` : ''}`;
					document.title = `${mangaTitleEl.textContent} - Ch. ${chapter.number}${chapter.title ? ` | ${chapter.title}` : ''}`;

					// If a ?scroll=<px> query param was included (from history links), prefer it
					// Read it before we replace the history state (which removes the query param)
					const urlParams = new URLSearchParams(window.location.search);
					const queryScroll = parseInt(urlParams.get('scroll') || '0', 10) || 0;
					history.replaceState(null, '', `/manga/${slug}/chapter-${chapter.number}`);
					pagesContainer.innerHTML = '<p class="muted">Loading pages...</p>';

					// Preload images
					let loadedImages = 0;
					let scrollRestored = false; // Prevent multiple scroll attempts
					const imageElements = chapter.pages.map(p => {
						const img = new Image();
						img.src = p;
						img.onload = () => {
							loadedImages++;
							if (loadedImages === chapter.pages.length && !scrollRestored) {
								pagesContainer.innerHTML = chapter.pages.map(pageSrc => `<img src="${pageSrc}" alt="Page">`).join('');
								scrollRestored = true;
								
								// Restore scroll position after all images are loaded
								if (queryScroll > 0) {
									// Small timeout to let layout settle after images render
									setTimeout(() => {
										window.scrollTo({ top: queryScroll, behavior: 'instant' });
									}, 100);
								} else {
									// Reset to top if no scroll position to restore
									window.scrollTo({ top: 0, behavior: 'instant' });
								}
							}
						};
						return img;
					});

					chapterSelect.selectedIndex = currentIndex;
					chapterSelectBottom.selectedIndex = currentIndex;

					// If no explicit query param scroll was provided, fall back to the server-stored value
					if (queryScroll <= 0) {
						try {
							fetch(`/api/history/scroll?manga_slug=${encodeURIComponent(slug)}&chapter=${chapter.number}`)
								.then(r => r.json())
								.then(j => {
									const target = parseInt(j && j.scroll || 0, 10) || 0;
									if (target > 0 && !scrollRestored) {
										// Allow time for images/layout to settle, then restore saved position
										setTimeout(() => {
											if (!scrollRestored) {
												window.scrollTo({ top: target, behavior: 'instant' });
												scrollRestored = true;
											}
										}, 800);
									}
								})
								.catch(() => {});
						} catch (e) { /* ignore */ }
					}

					// Setup scroll-saving for this chapter (debounced)
					setupScrollSaving(chapter.number);
				}

				prevBtn.onclick = () => navigateToChapter(currentIndex - 1);
				nextBtn.onclick = () => navigateToChapter(currentIndex + 1);
				chapterSelect.onchange = () => navigateToChapter(parseInt(chapterSelect.value));

				prevBtnBottom.onclick = () => navigateToChapter(currentIndex - 1);
				nextBtnBottom.onclick = () => navigateToChapter(currentIndex + 1);
				chapterSelectBottom.onchange = () => navigateToChapter(parseInt(chapterSelectBottom.value));

				loadChapter(currentIndex);
			})
			.catch(() => {
				pagesContainer.innerHTML = '<p class="muted">Failed to load chapters.</p>';
			});

		// Scroll saving logic (defined after the chapters are loaded so helper is available)
		let _scrollTimer = null;
		let _currentChapter = null;
		let _lastSavedScroll = -1; // Track last saved position to avoid redundant saves
		
		function setupScrollSaving(chapterNumber) {
			_currentChapter = chapterNumber;
			_lastSavedScroll = -1;

			// Remove previously attached handler, then add a fresh one
			window.removeEventListener('scroll', _onScroll);
			window.addEventListener('scroll', _onScroll);

			function _onScroll() {
				if (_scrollTimer) clearTimeout(_scrollTimer);
				_scrollTimer = setTimeout(() => {
					const currentScroll = Math.round(window.scrollY || window.pageYOffset || 0);
					// Only save if scroll position changed significantly (>50px difference)
					if (Math.abs(currentScroll - _lastSavedScroll) > 50) {
						sendScroll(_currentChapter, currentScroll);
						_lastSavedScroll = currentScroll;
					}
				}, 800); // Increased debounce time to reduce API calls
			}
		}

		function sendScroll(chapterNumber, scrollY) {
			try {
				// compute percent (approx) based on document height
				let percent = 0;
				try {
					const total = Math.max(document.documentElement.scrollHeight - window.innerHeight, 1);
					percent = Math.round((scrollY / total) * 100);
					if (percent < 0) percent = 0;
					if (percent > 100) percent = 100;
				} catch (e) { percent = 0; }
				
				// Send scroll position with error handling
				fetch('/api/history/scroll', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						manga_slug: slug, 
						chapter: chapterNumber, 
						scroll: scrollY, 
						percent: percent, 
						manga_title: mangaTitleEl.textContent || 'Unknown' 
					})
				}).catch(() => {
					// Silently handle network errors - scroll saving is not critical
					console.debug('Failed to save scroll position');
				});
			} catch (e) { 
				console.debug('Error in sendScroll:', e);
			}
		}
	</script>
</body>

</html>
